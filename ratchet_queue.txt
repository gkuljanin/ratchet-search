from sortedcontainers import SortedKeyList
import pandas as pd
import copy


class RatchetNode:

    def __init__(self, id: int, features: tuple):
        self.id = int(id)
        self.features = features

    def __repr__(self):
        return f'RatchetNode({self.id}, {self.features})'

    def __str__(self):
        return f'<RNode {self.id}: {self.features}>'

    def get_feature(self, idx: int):
        return self.features[idx]

    def get_distsq(self):
        return sum([f*f for f in self.features])

    # Returns true if all of the feature values are less than the comparator
    def under(self, comp_features: tuple):
        return all([my_val <= comp_val for my_val, comp_val in zip(self.features, comp_features)])

    def score(self, weights: tuple):
        return sum([val * wt for val, wt in zip(self.features, weights)])

    @staticmethod
    def score_list(lst, weights):
        return sum([node.score(weights) for node in lst])

# The queue should be ordered by magnitude from zero
# But filtered by the current largest values in the other two dimensions
# That way choosing this node can only add items in this direction
# New idea: Just one queue,
class RatchetQueue:

    def __init__(self):
        self._queue = SortedKeyList(key=lambda node: node.get_magsq())

    def __repr__(self):
        return f'<RatchetQueue({self.index}) {len(self._queue)} items>'

    def __str__(self):
        return f'<RQ {self.index}: head: {self._queue[0]}'

    def __copy__(self):
        cls = self.__class__
        result: RatchetQueue = cls.__new__(cls)
        result.index = self.index
        result._queue = self._queue.copy()
        return result

    def __deepcopy__(self, memo):
        cls = self.__class__
        result: RatchetQueue = cls.__new__(cls)
        result.index = self.index
        result._queue = self._queue.copy() # Don't copy nodes
        return result

    def update(self, lst: list):
        self._queue.update(lst)

    def add(self, item: RatchetNode):
        self._queue.add(item)

    def drop(self, items):
        for item in items:
            self._queue.remove(item)

    # Maybe the fix is here. Add a boundary so that the index can vary outside the box.
    def get_top(self, boundary):
        return self._queue[0]

    # returns a set of nodes to drop
    def calc_ratchet(self, boundary: tuple):
        my_feature = features[self.index]

        to_drop = {rn for rn in self._queue.irange_key(max_key=) \
                        if rn.under(features)}

        return to_drop

    def get_queue(self):
        return self._queue

    def queue_len(self):
        return len(self._queue)

# Must initialize with a boundary of inf, inf, inf ?
class RatchetColl:

    # Expected data frame configuration is
    # <id, f1, f2, ..., fk>
    # ids must be integers
    # features must be numeric
    def __init__(self, df: pd.DataFrame, weights: tuple):
        self._queues: list = [RatchetQueue(idx) for idx in range(df.shape[1]-1)]
        self._heuristic_list: SortedKeyList = SortedKeyList(key=lambda node: node.score(weights))
        self._dropped = set()
        self._weights = weights

        for _, row in df.iterrows():
            id = row[0]
            features = row[1:]
            self.add_to_all(id, tuple(features))

    def __repr__(self):
        return f'<RatchetColl() {len(self._queues)} queues>'

    def __copy__(self):
        cls = self.__class__
        result: RatchetColl = cls.__new__(cls)
        result._queues = self._queues.copy()
        result._heuristic_list = self._heuristic_list.copy()
        result._dropped = self._dropped.copy()
        result._weights = self._weights
        return result

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        result._queues = copy.deepcopy(self._queues, memo)
        result._heuristic_list = copy.copy(self._heuristic_list)
        result._dropped = self._dropped.copy()
        result._weights = copy.copy(self._weights)
        return result

    def add_to_all(self, id: int, features: tuple):
        rn = RatchetNode(id, features)
        for q in self._queues:
            q.add(rn)
        self._heuristic_list.add(rn)

    def ratchet(self, features: tuple):
        to_drop: set = set()
        for q in self._queues:
            to_drop = to_drop.union(q.calc_ratchet(features))
        return to_drop

    def clank(self, to_drop: set):
        for q in self._queues:
            q.drop(to_drop)
        for node in to_drop:
            self._heuristic_list.remove(node)
            self._dropped.add(node)

    def filter_node(self, node: RatchetNode):
        print(f'filtering node {node}')
        features = node.features
        to_drop = self.ratchet(features)
        self.clank(to_drop)

    def get_queues(self):
        return self._queues

    def get_queue_tops(self):
        return [q.get_top(self.get_boundary()) for q in self.get_queues()]

    def get_hlist(self):
        return self._heuristic_list

    def next_k_cost(self, k):
        return sum(self._heuristic_list[0:k])

    def get_dropped(self):
        return self._dropped

    def score_dropped(self):
        return RatchetNode.score_list(self.get_dropped(), self._weights)

    def get_boundary(self):
        tuples = [node.features for node in self.get_dropped()]
        feature_val_lists = zip(tuples)
        return [max(flist) for flist in feature_val_lists]
